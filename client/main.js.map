{"mappings":"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","sources":["./home/livid/github/other/markdown-preview-plus/node_modules/@parcel/scope-hoisting/lib/helpers.js","./lib-client/src-client/main.js","./node_modules/morphdom/dist/morphdom-esm.js","./lib-client/src-client/update-preview.js","./lib-client/src-client/mathjax-helper.js","./lib-client/src-client/util.js","./lib-client/src/util-common.js"],"sourcesContent":[null,"import { ipcRenderer } from 'electron';\nimport { UpdatePreview } from './update-preview';\nimport { MathJaxController, processHTMLString } from './mathjax-helper';\nimport * as util from './util';\nimport { getMedia } from '../src/util-common';\nlet handlerId;\nlet nativePageScrollKeys = false;\nwindow.addEventListener('error', (e) => {\n    const err = e.error;\n    ipcRenderer.send('atom-markdown-preview-plus-ipc-uncaught-error', handlerId, {\n        message: err.message,\n        name: err.name,\n        stack: err.stack,\n    });\n});\nwindow.addEventListener('unhandledrejection', (evt) => {\n    const err = evt.reason;\n    ipcRenderer.send('atom-markdown-preview-plus-ipc-uncaught-error', handlerId, {\n        message: err.message,\n        name: err.name,\n        stack: err.stack,\n    });\n});\nfunction mkResPromise() {\n    let resFn;\n    const p = new Promise((resolve) => (resFn = resolve));\n    p.resolve = resFn;\n    return p;\n}\nconst atomVars = {\n    mathJax: mkResPromise(),\n    sourceLineMap: new Map(),\n    revSourceMap: new WeakMap(),\n};\nipcRenderer.on('set-id', (_evt, id) => {\n    handlerId = id;\n});\nipcRenderer.on('init', (_evt, params) => {\n    atomVars.mathJax.resolve(MathJaxController.create(params.userMacros, params.mathJaxConfig));\n    document.documentElement.dataset.markdownPreviewPlusContext = params.context;\n    if (params.context === 'pdf-export') {\n        document.documentElement.style.setProperty('width', `${params.pdfExportOptions.width}mm`, 'important');\n    }\n});\nipcRenderer.on('set-native-keys', (_evt, val) => {\n    nativePageScrollKeys = val;\n});\nipcRenderer.on('set-source-map', (_evt, { map }) => {\n    const root = document.querySelector('div.update-preview');\n    if (!root)\n        throw new Error('No root element!');\n    const slsm = new Map();\n    const rsm = new WeakMap();\n    for (const [lineS, path] of Object.entries(map)) {\n        const line = parseInt(lineS, 10);\n        const elem = util.resolveElement(root, path);\n        if (elem) {\n            slsm.set(line, elem);\n            const rsmel = rsm.get(elem);\n            if (rsmel)\n                rsmel.push(line);\n            else\n                rsm.set(elem, [line]);\n        }\n    }\n    atomVars.sourceLineMap = slsm;\n    atomVars.revSourceMap = rsm;\n});\nipcRenderer.on('scroll-sync', (_evt, { firstLine, lastLine }) => {\n    const slm = atomVars.sourceLineMap;\n    const lines = Array.from(slm.keys()).sort((a, b) => a - b);\n    let lowix = lines.findIndex((x) => x >= firstLine);\n    if (lowix > 0)\n        lowix--;\n    let highix = lines.findIndex((x) => x >= lastLine);\n    if (highix === -1)\n        highix = lines.length - 1;\n    else if (highix < lines.length - 1)\n        highix++;\n    const low = lines[lowix];\n    const high = lines[highix];\n    let norm = 0;\n    let meanScroll = 0;\n    const entries = Array.from(slm.entries()).slice(lowix, highix + 1);\n    for (const [line, item] of entries) {\n        const weight = line <= (high + low) / 2 ? line - low + 1 : high - line + 1;\n        norm += weight;\n        meanScroll += item.getBoundingClientRect().top * weight;\n    }\n    if (norm === 0)\n        return;\n    const offset = document.documentElement.scrollTop;\n    const clientHeight = document.documentElement.clientHeight;\n    const top = offset - clientHeight / 2 + meanScroll / norm;\n    window.scroll({ top });\n});\nipcRenderer.on('style', (_event, { styles }) => {\n    let styleElem = document.head.querySelector('style#atom-styles');\n    if (!styleElem) {\n        styleElem = document.createElement('style');\n        styleElem.id = 'atom-styles';\n        document.head.appendChild(styleElem);\n    }\n    styleElem.innerHTML = styles.join('\\n');\n});\nipcRenderer.on('update-images', (_event, { oldsrc, v }) => {\n    const imgs = getMedia(document);\n    for (const img of Array.from(imgs)) {\n        let ovs;\n        let ov;\n        let attrName;\n        if (img.tagName === 'LINK')\n            attrName = 'href';\n        else\n            attrName = 'src';\n        let src = img.getAttribute(attrName);\n        const match = src.match(/^(.*)\\?v=(\\d+)$/);\n        if (match)\n            [, src, ovs] = match;\n        if (src === oldsrc) {\n            if (ovs !== undefined)\n                ov = parseInt(ovs, 10);\n            if (v !== ov)\n                img[attrName] = v ? `${src}?v=${v}` : `${src}`;\n        }\n    }\n});\nipcRenderer.on('sync', (_event, { line, flash }) => {\n    const root = document.querySelector('div.update-preview');\n    if (!root)\n        return;\n    let element = atomVars.sourceLineMap.get(line);\n    if (!element) {\n        for (let i = line - 1; i >= 0; i -= 1) {\n            element = atomVars.sourceLineMap.get(line);\n            if (element)\n                break;\n        }\n    }\n    if (!element)\n        return;\n    element.scrollIntoViewIfNeeded(true);\n    if (flash) {\n        element.classList.add('flash');\n        setTimeout(() => element.classList.remove('flash'), 1000);\n    }\n});\nlet updatePreview;\nipcRenderer.on('update-preview', async (_event, { id, html, renderLaTeX }) => {\n    const preview = document.querySelector('div.update-preview');\n    if (!preview)\n        return;\n    if (!updatePreview) {\n        updatePreview = new UpdatePreview(preview, await atomVars.mathJax);\n    }\n    const parser = new DOMParser();\n    const domDocument = parser.parseFromString(html, 'text/html');\n    const doc = document;\n    if (doc && domDocument.head.hasChildNodes) {\n        let container = doc.head.querySelector('original-elements');\n        if (!container) {\n            container = doc.createElement('original-elements');\n            doc.head.appendChild(container);\n        }\n        container.innerHTML = '';\n        for (const headElement of Array.from(domDocument.head.childNodes)) {\n            container.appendChild(headElement);\n        }\n    }\n    await updatePreview.update(domDocument.body, renderLaTeX);\n    ipcRenderer.send('atom-markdown-preview-plus-ipc-request-reply', handlerId, {\n        id,\n        request: 'update-preview',\n        result: processHTMLString(preview),\n    });\n});\nipcRenderer.on('await-fully-ready', async (_event, { id }) => {\n    if (document.readyState === 'complete') {\n        ipcRenderer.send('atom-markdown-preview-plus-ipc-request-reply', handlerId, {\n            id,\n            request: 'await-fully-ready',\n            result: void 0,\n        });\n        return;\n    }\n    function loaded() {\n        ipcRenderer.send('atom-markdown-preview-plus-ipc-request-reply', handlerId, {\n            id,\n            request: 'await-fully-ready',\n            result: void 0,\n        });\n        document.removeEventListener('load', loaded);\n    }\n    document.addEventListener('load', loaded);\n});\nconst baseElement = document.createElement('base');\ndocument.head.appendChild(baseElement);\nipcRenderer.on('set-base-path', (_evt, { path }) => {\n    if (path)\n        baseElement.href = path;\n    else\n        baseElement.href = '';\n});\nipcRenderer.on('error', (_evt, { msg }) => {\n    const preview = document.querySelector('div.update-preview');\n    if (!preview)\n        return;\n    const errorDiv = document.createElement('div');\n    errorDiv.innerHTML = `<h2>Previewing Markdown Failed</h2><h3>${msg}</h3>`;\n    preview.appendChild(errorDiv);\n});\ndocument.addEventListener('wheel', (event) => {\n    if (event.ctrlKey) {\n        if (event.deltaY > 0) {\n            ipcRenderer.send('atom-markdown-preview-plus-ipc-zoom-in', handlerId);\n        }\n        else if (event.deltaY < 0) {\n            ipcRenderer.send('atom-markdown-preview-plus-ipc-zoom-out', handlerId);\n        }\n        event.preventDefault();\n        event.stopPropagation();\n    }\n});\ndocument.addEventListener('scroll', (_event) => {\n    const el = document.documentElement;\n    const height = el.clientHeight;\n    const visible = Array.from(atomVars.sourceLineMap.entries())\n        .filter(([_line, elem]) => {\n        const { top, bottom } = elem.getBoundingClientRect();\n        return top > 0 && bottom < height;\n    })\n        .map(([line, _elem]) => line);\n    ipcRenderer.send('atom-markdown-preview-plus-ipc-did-scroll-preview', handlerId, {\n        max: Math.max(...visible),\n        min: Math.min(...visible),\n    });\n});\nfunction keyEventHandler(type, e) {\n    if (nativePageScrollKeys &&\n        !e.altKey &&\n        !e.ctrlKey &&\n        !e.shiftKey &&\n        !e.metaKey &&\n        e.code.match(/^(Arrow.*|Page.*|Space|Home|End)$/)) {\n        return;\n    }\n    const data = {\n        type: type,\n        altKey: e.altKey,\n        ctrlKey: e.ctrlKey,\n        bubbles: e.bubbles,\n        cancelable: e.cancelable,\n        code: e.code,\n        composed: e.composed,\n        detail: e.detail,\n        isComposing: e.isComposing,\n        key: e.key,\n        location: e.location,\n        metaKey: e.metaKey,\n        repeat: e.repeat,\n        shiftKey: e.shiftKey,\n    };\n    ipcRenderer.send('atom-markdown-preview-plus-ipc-key', handlerId, data);\n    e.preventDefault();\n}\ndocument.addEventListener('keydown', keyEventHandler.bind(this, 'keydown'));\ndocument.addEventListener('keyup', keyEventHandler.bind(this, 'keyup'));\nlet lastContextMenuTarget;\ndocument.addEventListener('contextmenu', (e) => {\n    lastContextMenuTarget = e.target;\n    ipcRenderer.send('atom-markdown-preview-plus-ipc-show-context-menu', handlerId);\n});\nipcRenderer.on('sync-source', (_, { id }) => {\n    let element = lastContextMenuTarget;\n    const rsm = atomVars.revSourceMap;\n    let lines = rsm.get(element);\n    while (!lines && element.parentElement) {\n        element = element.parentElement;\n        lines = rsm.get(element);\n    }\n    if (!lines)\n        return;\n    ipcRenderer.send('atom-markdown-preview-plus-ipc-request-reply', handlerId, {\n        id,\n        request: 'sync-source',\n        result: Math.min(...lines),\n    });\n});\nipcRenderer.on('reload', (_, { id }) => {\n    window.onbeforeunload = null;\n    ipcRenderer.send('atom-markdown-preview-plus-ipc-request-reply', handlerId, {\n        id,\n        request: 'reload',\n        result: undefined,\n    });\n});\nwindow.onbeforeunload = function () {\n    return false;\n};\nipcRenderer.on('get-tex-config', async (_, { id }) => {\n    ipcRenderer.send('atom-markdown-preview-plus-ipc-request-reply', handlerId, {\n        id,\n        request: 'get-tex-config',\n        result: (await atomVars.mathJax).jaxTeXConfig(),\n    });\n});\nipcRenderer.on('get-selection', async (_, { id }) => {\n    const selection = window.getSelection();\n    const selectedText = selection && selection.toString();\n    const selectedNode = selection && selection.anchorNode;\n    ipcRenderer.send('atom-markdown-preview-plus-ipc-request-reply', handlerId, {\n        id,\n        request: 'get-selection',\n        result: selectedText && selectedNode ? selectedText : undefined,\n    });\n});\ndocument.addEventListener('click', (event) => {\n    if (!event.target)\n        return;\n    const el = event.target;\n    if (el.tagName === 'A') {\n        const href = el.getAttribute('href');\n        if (href && href.startsWith('#')) {\n            event.preventDefault();\n            const anchor = document.getElementById(decodeURIComponent(href).slice(1));\n            if (anchor)\n                anchor.scrollIntoView();\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy1jbGllbnQvbWFpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sVUFBVSxDQUFBO0FBQ3RDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQTtBQUNoRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQTtBQUN2RSxPQUFPLEtBQUssSUFBSSxNQUFNLFFBQVEsQ0FBQTtBQUM5QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sb0JBQW9CLENBQUE7QUFFN0MsSUFBSSxTQUFpQixDQUFBO0FBQ3JCLElBQUksb0JBQW9CLEdBQUcsS0FBSyxDQUFBO0FBRWhDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRTtJQUNyQyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsS0FBYyxDQUFBO0lBQzVCLFdBQVcsQ0FBQyxJQUFJLENBQ2QsK0NBQStDLEVBQy9DLFNBQVMsRUFDVDtRQUNFLE9BQU8sRUFBRSxHQUFHLENBQUMsT0FBTztRQUNwQixJQUFJLEVBQUUsR0FBRyxDQUFDLElBQUk7UUFDZCxLQUFLLEVBQUUsR0FBRyxDQUFDLEtBQUs7S0FDakIsQ0FDRixDQUFBO0FBQ0gsQ0FBQyxDQUFDLENBQUE7QUFFRixNQUFNLENBQUMsZ0JBQWdCLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRTtJQUNwRCxNQUFNLEdBQUcsR0FBSSxHQUFXLENBQUMsTUFBZSxDQUFBO0lBQ3hDLFdBQVcsQ0FBQyxJQUFJLENBQ2QsK0NBQStDLEVBQy9DLFNBQVMsRUFDVDtRQUNFLE9BQU8sRUFBRSxHQUFHLENBQUMsT0FBTztRQUNwQixJQUFJLEVBQUUsR0FBRyxDQUFDLElBQUk7UUFDZCxLQUFLLEVBQUUsR0FBRyxDQUFDLEtBQUs7S0FD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QUMsQ0FBQyxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXBjUmVuZGVyZXIgfSBmcm9tICdlbGVjdHJvbidcbmltcG9ydCB7IFVwZGF0ZVByZXZpZXcgfSBmcm9tICcuL3VwZGF0ZS1wcmV2aWV3J1xuaW1wb3J0IHsgTWF0aEpheENvbnRyb2xsZXIsIHByb2Nlc3NIVE1MU3RyaW5nIH0gZnJvbSAnLi9tYXRoamF4LWhlbHBlcidcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsJ1xuaW1wb3J0IHsgZ2V0TWVkaWEgfSBmcm9tICcuLi9zcmMvdXRpbC1jb21tb24nXG5cbmxldCBoYW5kbGVySWQ6IG51bWJlclxubGV0IG5hdGl2ZVBhZ2VTY3JvbGxLZXlzID0gZmFsc2Vcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGUpID0+IHtcbiAgY29uc3QgZXJyID0gZS5lcnJvciBhcyBFcnJvclxuICBpcGNSZW5kZXJlci5zZW5kPCdhdG9tLW1hcmtkb3duLXByZXZpZXctcGx1cy1pcGMtdW5jYXVnaHQtZXJyb3InPihcbiAgICAnYXRvbS1tYXJrZG93bi1wcmV2aWV3LXBsdXMtaXBjLXVuY2F1Z2h0LWVycm9yJyxcbiAgICBoYW5kbGVySWQsXG4gICAge1xuICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICBuYW1lOiBlcnIubmFtZSxcbiAgICAgIHN0YWNrOiBlcnIuc3RhY2ssXG4gICAgfSxcbiAgKVxufSlcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIChldnQpID0+IHtcbiAgY29uc3QgZXJyID0gKGV2dCBhcyBhbnkpLnJlYXNvbiBhcyBFcnJvclxuICBpcGNSZW5kZXJlci5zZW5kPCdhdG9tLW1hcmtkb3duLXByZXZpZXctcGx1cy1pcGMtdW5jYXVnaHQtZXJyb3InPihcbiAgICAnYXRvbS1tYXJrZG93bi1wcmV2aWV3LXBsdXMtaXBjLXVuY2F1Z2h0LWVycm9yJyxcbiAgICBoYW5kbGVySWQsXG4gICAge1xuICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICBuYW1lOiBlcnIubmFtZSxcbiAgICAgIHN0YWNrOiBlcnIuc3RhY2ssXG4gICAgfSxcbiAgKVxufSlcblxuZnVuY3Rpb24gbWtSZXNQcm9taXNlPFQ+KCkge1xuICBsZXQgcmVzRm46ICh2YWx1ZT86IFQgfCBQcm9taXNlTGlrZTxUPiB8IHVuZGVmaW5lZCkgPT4gdm9pZFxuICBjb25zdCBwID0gbmV3IFByb21pc2U8VD4oKHJlc29sdmUpID0+IChyZXNGbiA9IHJlc29sdmUpKSBhcyBQcm9taXNlPFQ+ICYge1xuICAgIHJlc29sdmU6IHR5cGVvZiByZXNGblxuICB9XG4gIHAucmVzb2x2ZSA9IHJlc0ZuIVxuICByZXR1cm4gcFxufVxuXG5jb25zdCBhdG9tVmFycyA9IHtcbiAgbWF0aEpheDogbWtSZXNQcm9taXNlPE1hdGhKYXhDb250cm9sbGVyPigpLFxuICBzb3VyY2VMaW5lTWFwOiBuZXcgTWFwPG51bWJlciwgRWxlbWVudD4oKSxcbiAgcmV2U291cmNlTWFwOiBuZXcgV2Vha01hcDxFbGVtZW50LCBudW1iZXJbXT4oKSxcbn1cblxuaXBjUmVuZGVyZXIub248J3NldC1pZCc+KCdzZXQtaWQnLCAoX2V2dCwgaWQpID0+IHtcbiAgaGFuZGxlcklkID0gaWRcbn0pXG5cbmlwY1JlbmRlcmVyLm9uPCdpbml0Jz4oJ2luaXQnLCAoX2V2dCwgcGFyYW1zKSA9PiB7XG4gIGF0b21WYXJzLm1hdGhKYXgucmVzb2x2ZShcbiAgICBNYXRoSmF4Q29udHJvbGxlci5jcmVhdGUocGFyYW1zLnVzZXJNYWNyb3MsIHBhcmFtcy5tYXRoSmF4Q29uZmlnKSxcbiAgKVxuICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQhLmRhdGFzZXQubWFya2Rvd25QcmV2aWV3UGx1c0NvbnRleHQgPSBwYXJhbXMuY29udGV4dFxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dG90YWxpdHktY2hlY2tcbiAgaWYgKHBhcmFtcy5jb250ZXh0ID09PSAncGRmLWV4cG9ydCcpIHtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQhLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgJ3dpZHRoJyxcbiAgICAgIGAke3BhcmFtcy5wZGZFeHBvcnRPcHRpb25zLndpZHRofW1tYCxcbiAgICAgICdpbXBvcnRhbnQnLFxuICAgIClcbiAgfVxufSlcblxuaXBjUmVuZGVyZXIub248J3NldC1uYXRpdmUta2V5cyc+KCdzZXQtbmF0aXZlLWtleXMnLCAoX2V2dCwgdmFsKSA9PiB7XG4gIG5hdGl2ZVBhZ2VTY3JvbGxLZXlzID0gdmFsXG59KVxuXG5pcGNSZW5kZXJlci5vbjwnc2V0LXNvdXJjZS1tYXAnPignc2V0LXNvdXJjZS1tYXAnLCAoX2V2dCwgeyBtYXAgfSkgPT4ge1xuICBjb25zdCByb290ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZGl2LnVwZGF0ZS1wcmV2aWV3JylcbiAgaWYgKCFyb290KSB0aHJvdyBuZXcgRXJyb3IoJ05vIHJvb3QgZWxlbWVudCEnKVxuICBjb25zdCBzbHNtID0gbmV3IE1hcDxudW1iZXIsIEVsZW1lbnQ+KClcbiAgY29uc3QgcnNtID0gbmV3IFdlYWtNYXA8RWxlbWVudCwgbnVtYmVyW10+KClcbiAgZm9yIChjb25zdCBbbGluZVMsIHBhdGhdIG9mIE9iamVjdC5lbnRyaWVzKG1hcCkpIHtcbiAgICBjb25zdCBsaW5lID0gcGFyc2VJbnQobGluZVMsIDEwKVxuICAgIGNvbnN0IGVsZW0gPSB1dGlsLnJlc29sdmVFbGVtZW50KHJvb3QsIHBhdGgpXG4gICAgaWYgKGVsZW0pIHtcbiAgICAgIHNsc20uc2V0KGxpbmUsIGVsZW0pXG4gICAgICBjb25zdCByc21lbCA9IHJzbS5nZXQoZWxlbSlcbiAgICAgIGlmIChyc21lbCkgcnNtZWwucHVzaChsaW5lKVxuICAgICAgZWxzZSByc20uc2V0KGVsZW0sIFtsaW5lXSlcbiAgICB9XG4gIH1cbiAgYXRvbVZhcnMuc291cmNlTGluZU1hcCA9IHNsc21cbiAgYXRvbVZhcnMucmV2U291cmNlTWFwID0gcnNtXG59KVxuXG5pcGNSZW5kZXJlci5vbjwnc2Nyb2xsLXN5bmMnPihcbiAgJ3Njcm9sbC1zeW5jJyxcbiAgKF9ldnQsIHsgZmlyc3RMaW5lLCBsYXN0TGluZSB9KSA9PiB7XG4gICAgY29uc3Qgc2xtID0gYXRvbVZhcnMuc291cmNlTGluZU1hcFxuICAgIGNvbnN0IGxpbmVzID0gQXJyYXkuZnJvbShzbG0ua2V5cygpKS5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICBsZXQgbG93aXggPSBsaW5lcy5maW5kSW5kZXgoKHgpID0+IHggPj0gZmlyc3RMaW5lKVxuICAgIGlmIChsb3dpeCA+IDApIGxvd2l4LS1cbiAgICBsZXQgaGlnaGl4ID0gbGluZXMuZmluZEluZGV4KCh4KSA9PiB4ID49IGxhc3RMaW5lKVxuICAgIGlmIChoaWdoaXggPT09IC0xKSBoaWdoaXggPSBsaW5lcy5sZW5ndGggLSAxXG4gICAgZWxzZSBpZiAoaGlnaGl4IDwgbGluZXMubGVuZ3RoIC0gMSkgaGlnaGl4KytcbiAgICBjb25zdCBsb3cgPSBsaW5lc1tsb3dpeF1cbiAgICBjb25zdCBoaWdoID0gbGluZXNbaGlnaGl4XVxuICAgIGxldCBub3JtID0gMFxuICAgIGxldCBtZWFuU2Nyb2xsID0gMFxuICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKHNsbS5lbnRyaWVzKCkpLnNsaWNlKGxvd2l4LCBoaWdoaXggKyAxKVxuICAgIGZvciAoY29uc3QgW2xpbmUsIGl0ZW1dIG9mIGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHdlaWdodCA9IGxpbmUgPD0gKGhpZ2ggKyBsb3cpIC8gMiA/IGxpbmUgLSBsb3cgKyAxIDogaGlnaCAtIGxpbmUgKyAxXG4gICAgICBub3JtICs9IHdlaWdodFxuICAgICAgbWVhblNjcm9sbCArPSBpdGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAqIHdlaWdodFxuICAgIH1cbiAgICBpZiAobm9ybSA9PT0gMCkgcmV0dXJuXG4gICAgY29uc3Qgb2Zmc2V0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IS5zY3JvbGxUb3BcbiAgICBjb25zdCBjbGllbnRIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQhLmNsaWVudEhlaWdodFxuICAgIGNvbnN0IHRvcCA9IG9mZnNldCAtIGNsaWVudEhlaWdodCAvIDIgKyBtZWFuU2Nyb2xsIC8gbm9ybVxuICAgIHdpbmRvdy5zY3JvbGwoeyB0b3AgfSlcbiAgfSxcbilcblxuaXBjUmVuZGVyZXIub248J3N0eWxlJz4oJ3N0eWxlJywgKF9ldmVudCwgeyBzdHlsZXMgfSkgPT4ge1xuICBsZXQgc3R5bGVFbGVtID0gZG9jdW1lbnQuaGVhZCEucXVlcnlTZWxlY3Rvcignc3R5bGUjYXRvbS1zdHlsZXMnKVxuICBpZiAoIXN0eWxlRWxlbSkge1xuICAgIHN0eWxlRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgICBzdHlsZUVsZW0uaWQgPSAnYXRvbS1zdHlsZXMnXG4gICAgZG9jdW1lbnQuaGVhZCEuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtKVxuICB9XG4gIHN0eWxlRWxlbS5pbm5lckhUTUwgPSBzdHlsZXMuam9pbignXFxuJylcbn0pXG5cbmlwY1JlbmRlcmVyLm9uPCd1cGRhdGUtaW1hZ2VzJz4oJ3VwZGF0ZS1pbWFnZXMnLCAoX2V2ZW50LCB7IG9sZHNyYywgdiB9KSA9PiB7XG4gIGNvbnN0IGltZ3MgPSBnZXRNZWRpYShkb2N1bWVudClcbiAgZm9yIChjb25zdCBpbWcgb2YgQXJyYXkuZnJvbShpbWdzKSkge1xuICAgIGxldCBvdnM6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIGxldCBvdjogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgbGV0IGF0dHJOYW1lOiAnaHJlZicgfCAnc3JjJ1xuICAgIGlmIChpbWcudGFnTmFtZSA9PT0gJ0xJTksnKSBhdHRyTmFtZSA9ICdocmVmJ1xuICAgIGVsc2UgYXR0ck5hbWUgPSAnc3JjJ1xuICAgIGxldCBzcmMgPSBpbWcuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSFcbiAgICBjb25zdCBtYXRjaCA9IHNyYy5tYXRjaCgvXiguKilcXD92PShcXGQrKSQvKVxuICAgIGlmIChtYXRjaCkgWywgc3JjLCBvdnNdID0gbWF0Y2hcbiAgICBpZiAoc3JjID09PSBvbGRzcmMpIHtcbiAgICAgIGlmIChvdnMgIT09IHVuZGVmaW5lZCkgb3YgPSBwYXJzZUludChvdnMsIDEwKVxuICAgICAgaWYgKHYgIT09IG92KSBpbWdbYXR0ck5hbWVdID0gdiA/IGAke3NyY30/dj0ke3Z9YCA6IGAke3NyY31gXG4gICAgfVxuICB9XG59KVxuXG5pcGNSZW5kZXJlci5vbjwnc3luYyc+KCdzeW5jJywgKF9ldmVudCwgeyBsaW5lLCBmbGFzaCB9KSA9PiB7XG4gIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdkaXYudXBkYXRlLXByZXZpZXcnKVxuICBpZiAoIXJvb3QpIHJldHVyblxuXG4gIGxldCBlbGVtZW50ID0gYXRvbVZhcnMuc291cmNlTGluZU1hcC5nZXQobGluZSlcblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICBmb3IgKGxldCBpID0gbGluZSAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBlbGVtZW50ID0gYXRvbVZhcnMuc291cmNlTGluZU1hcC5nZXQobGluZSlcbiAgICAgIGlmIChlbGVtZW50KSBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICghZWxlbWVudCkgcmV0dXJuXG5cbiAgZWxlbWVudC5zY3JvbGxJbnRvVmlld0lmTmVlZGVkKHRydWUpXG5cbiAgaWYgKGZsYXNoKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmbGFzaCcpXG4gICAgc2V0VGltZW91dCgoKSA9PiBlbGVtZW50IS5jbGFzc0xpc3QucmVtb3ZlKCdmbGFzaCcpLCAxMDAwKVxuICB9XG59KVxuXG5sZXQgdXBkYXRlUHJldmlldzogVXBkYXRlUHJldmlldyB8IHVuZGVmaW5lZFxuXG5pcGNSZW5kZXJlci5vbjwndXBkYXRlLXByZXZpZXcnPihcbiAgJ3VwZGF0ZS1wcmV2aWV3JyxcbiAgYXN5bmMgKF9ldmVudCwgeyBpZCwgaHRtbCwgcmVuZGVyTGFUZVggfSkgPT4ge1xuICAgIC8vIGRpdi51cGRhdGUtcHJldmlldyBjcmVhdGVkIGFmdGVyIGNvbnN0cnVjdG9yIHN0IFVwZGF0ZVByZXZpZXcgY2Fubm90XG4gICAgLy8gYmUgaW5zdGFuY2VkIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdkaXYudXBkYXRlLXByZXZpZXcnKVxuICAgIGlmICghcHJldmlldykgcmV0dXJuXG4gICAgaWYgKCF1cGRhdGVQcmV2aWV3KSB7XG4gICAgICB1cGRhdGVQcmV2aWV3ID0gbmV3IFVwZGF0ZVByZXZpZXcoXG4gICAgICAgIHByZXZpZXcgYXMgSFRNTEVsZW1lbnQsXG4gICAgICAgIGF3YWl0IGF0b21WYXJzLm1hdGhKYXgsXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKVxuICAgIGNvbnN0IGRvbURvY3VtZW50ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sLCAndGV4dC9odG1sJylcbiAgICBjb25zdCBkb2MgPSBkb2N1bWVudFxuICAgIGlmIChkb2MgJiYgZG9tRG9jdW1lbnQuaGVhZCEuaGFzQ2hpbGROb2Rlcykge1xuICAgICAgbGV0IGNvbnRhaW5lciA9IGRvYy5oZWFkIS5xdWVyeVNlbGVjdG9yKCdvcmlnaW5hbC1lbGVtZW50cycpXG4gICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICBjb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnb3JpZ2luYWwtZWxlbWVudHMnKVxuICAgICAgICBkb2MuaGVhZCEuYXBwZW5kQ2hpbGQoY29udGFpbmVyKVxuICAgICAgfVxuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnXG4gICAgICBmb3IgKGNvbnN0IGhlYWRFbGVtZW50IG9mIEFycmF5LmZyb20oZG9tRG9jdW1lbnQuaGVhZCEuY2hpbGROb2RlcykpIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGhlYWRFbGVtZW50KVxuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB1cGRhdGVQcmV2aWV3LnVwZGF0ZShkb21Eb2N1bWVudC5ib2R5LCByZW5kZXJMYVRlWClcbiAgICBpcGNSZW5kZXJlci5zZW5kPCdhdG9tLW1hcmtkb3duLXByZXZpZXctcGx1cy1pcGMtcmVxdWVzdC1yZXBseSc+KFxuICAgICAgJ2F0b20tbWFya2Rvd24tcHJldmlldy1wbHVzLWlwYy1yZXF1ZXN0LXJlcGx5JyxcbiAgICAgIGhhbmRsZXJJZCxcbiAgICAgIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHJlcXVlc3Q6ICd1cGRhdGUtcHJldmlldycsXG4gICAgICAgIHJlc3VsdDogcHJvY2Vzc0hUTUxTdHJpbmcocHJldmlldyksXG4gICAgICB9LFxuICAgIClcbiAgfSxcbilcblxuaXBjUmVuZGVyZXIub248J2F3YWl0LWZ1bGx5LXJlYWR5Jz4oXG4gICdhd2FpdC1mdWxseS1yZWFkeScsXG4gIGFzeW5jIChfZXZlbnQsIHsgaWQgfSkgPT4ge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogdG90YWxpdHktY2hlY2tcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgaXBjUmVuZGVyZXIuc2VuZDwnYXRvbS1tYXJrZG93bi1wcmV2aWV3LXBsdXMtaXBjLXJlcXVlc3QtcmVwbHknPihcbiAgICAgICAgJ2F0b20tbWFya2Rvd24tcHJldmlldy1wbHVzLWlwYy1yZXF1ZXN0LXJlcGx5JyxcbiAgICAgICAgaGFuZGxlcklkLFxuICAgICAgICB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcmVxdWVzdDogJ2F3YWl0LWZ1bGx5LXJlYWR5JyxcbiAgICAgICAgICByZXN1bHQ6IHZvaWQgMCxcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBmdW5jdGlvbiBsb2FkZWQoKSB7XG4gICAgICBpcGNSZW5kZXJlci5zZW5kPCdhdG9tLW1hcmtkb3duLXByZXZpZXctcGx1cy1pcGMtcmVxdWVzdC1yZXBseSc+KFxuICAgICAgICAnYXRvbS1tYXJrZG93bi1wcmV2aWV3LXBsdXMtaXBjLXJlcXVlc3QtcmVwbHknLFxuICAgICAgICBoYW5kbGVySWQsXG4gICAgICAgIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICByZXF1ZXN0OiAnYXdhaXQtZnVsbHktcmVhZHknLFxuICAgICAgICAgIHJlc3VsdDogdm9pZCAwLFxuICAgICAgICB9LFxuICAgICAgKVxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRlZClcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRlZClcbiAgfSxcbilcblxuY29uc3QgYmFzZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdiYXNlJylcbmRvY3VtZW50LmhlYWQhLmFwcGVuZENoaWxkKGJhc2VFbGVtZW50KVxuXG5pcGNSZW5kZXJlci5vbjwnc2V0LWJhc2UtcGF0aCc+KCdzZXQtYmFzZS1wYXRoJywgKF9ldnQsIHsgcGF0aCB9KSA9PiB7XG4gIGlmIChwYXRoKSBiYXNlRWxlbWVudC5ocmVmID0gcGF0aFxuICBlbHNlIGJhc2VFbGVtZW50LmhyZWYgPSAnJ1xufSlcblxuaXBjUmVuZGVyZXIub248J2Vycm9yJz4oJ2Vycm9yJywgKF9ldnQsIHsgbXNnIH0pID0+IHtcbiAgY29uc3QgcHJldmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Rpdi51cGRhdGUtcHJldmlldycpXG4gIGlmICghcHJldmlldykgcmV0dXJuXG4gIGNvbnN0IGVycm9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgZXJyb3JEaXYuaW5uZXJIVE1MID0gYDxoMj5QcmV2aWV3aW5nIE1hcmtkb3duIEZhaWxlZDwvaDI+PGgzPiR7bXNnfTwvaDM+YFxuICBwcmV2aWV3LmFwcGVuZENoaWxkKGVycm9yRGl2KVxufSlcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCAoZXZlbnQpID0+IHtcbiAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICBpZiAoZXZlbnQuZGVsdGFZID4gMCkge1xuICAgICAgaXBjUmVuZGVyZXIuc2VuZDwnYXRvbS1tYXJrZG93bi1wcmV2aWV3LXBsdXMtaXBjLXpvb20taW4nPihcbiAgICAgICAgJ2F0b20tbWFya2Rvd24tcHJldmlldy1wbHVzLWlwYy16b29tLWluJyxcbiAgICAgICAgaGFuZGxlcklkLFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoZXZlbnQuZGVsdGFZIDwgMCkge1xuICAgICAgaXBjUmVuZGVyZXIuc2VuZDwnYXRvbS1tYXJrZG93bi1wcmV2aWV3LXBsdXMtaXBjLXpvb20tb3V0Jz4oXG4gICAgICAgICdhdG9tLW1hcmtkb3duLXByZXZpZXctcGx1cy1pcGMtem9vbS1vdXQnLFxuICAgICAgICBoYW5kbGVySWQsXG4gICAgICApXG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICB9XG59KVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoX2V2ZW50KSA9PiB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IVxuICBjb25zdCBoZWlnaHQgPSBlbC5jbGllbnRIZWlnaHRcbiAgY29uc3QgdmlzaWJsZSA9IEFycmF5LmZyb20oYXRvbVZhcnMuc291cmNlTGluZU1hcC5lbnRyaWVzKCkpXG4gICAgLmZpbHRlcigoW19saW5lLCBlbGVtXSkgPT4ge1xuICAgICAgY29uc3QgeyB0b3AsIGJvdHRvbSB9ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgcmV0dXJuIHRvcCA+IDAgJiYgYm90dG9tIDwgaGVpZ2h0XG4gICAgfSlcbiAgICAubWFwKChbbGluZSwgX2VsZW1dKSA9PiBsaW5lKVxuICBpcGNSZW5kZXJlci5zZW5kPCdhdG9tLW1hcmtkb3duLXByZXZpZXctcGx1cy1pcGMtZGlkLXNjcm9sbC1wcmV2aWV3Jz4oXG4gICAgJ2F0b20tbWFya2Rvd24tcHJldmlldy1wbHVzLWlwYy1kaWQtc2Nyb2xsLXByZXZpZXcnLFxuICAgIGhhbmRsZXJJZCxcbiAgICB7XG4gICAgICBtYXg6IE1hdGgubWF4KC4uLnZpc2libGUpLFxuICAgICAgbWluOiBNYXRoLm1pbiguLi52aXNpYmxlKSxcbiAgICB9LFxuICApXG59KVxuXG5mdW5jdGlvbiBrZXlFdmVudEhhbmRsZXIodHlwZTogJ2tleWRvd24nIHwgJ2tleXVwJywgZTogS2V5Ym9hcmRFdmVudCkge1xuICBpZiAoXG4gICAgbmF0aXZlUGFnZVNjcm9sbEtleXMgJiZcbiAgICAhZS5hbHRLZXkgJiZcbiAgICAhZS5jdHJsS2V5ICYmXG4gICAgIWUuc2hpZnRLZXkgJiZcbiAgICAhZS5tZXRhS2V5ICYmXG4gICAgZS5jb2RlLm1hdGNoKC9eKEFycm93Lip8UGFnZS4qfFNwYWNlfEhvbWV8RW5kKSQvKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBkYXRhID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgYWx0S2V5OiBlLmFsdEtleSxcbiAgICBjdHJsS2V5OiBlLmN0cmxLZXksXG4gICAgYnViYmxlczogZS5idWJibGVzLFxuICAgIGNhbmNlbGFibGU6IGUuY2FuY2VsYWJsZSxcbiAgICBjb2RlOiBlLmNvZGUsXG4gICAgY29tcG9zZWQ6IGUuY29tcG9zZWQsXG4gICAgZGV0YWlsOiBlLmRldGFpbCxcbiAgICBpc0NvbXBvc2luZzogZS5pc0NvbXBvc2luZyxcbiAgICBrZXk6IGUua2V5LFxuICAgIGxvY2F0aW9uOiBlLmxvY2F0aW9uLFxuICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAgICByZXBlYXQ6IGUucmVwZWF0LFxuICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICB9IGFzIGNvbnN0XG4gIGlwY1JlbmRlcmVyLnNlbmQ8J2F0b20tbWFya2Rvd24tcHJldmlldy1wbHVzLWlwYy1rZXknPihcbiAgICAnYXRvbS1tYXJrZG93bi1wcmV2aWV3LXBsdXMtaXBjLWtleScsXG4gICAgaGFuZGxlcklkLFxuICAgIGRhdGEsXG4gIClcbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG59XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAna2V5ZG93bicpKVxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXlFdmVudEhhbmRsZXIuYmluZCh0aGlzLCAna2V5dXAnKSlcblxubGV0IGxhc3RDb250ZXh0TWVudVRhcmdldDogSFRNTEVsZW1lbnRcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGUpID0+IHtcbiAgbGFzdENvbnRleHRNZW51VGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTEVsZW1lbnRcbiAgaXBjUmVuZGVyZXIuc2VuZDwnYXRvbS1tYXJrZG93bi1wcmV2aWV3LXBsdXMtaXBjLXNob3ctY29udGV4dC1tZW51Jz4oXG4gICAgJ2F0b20tbWFya2Rvd24tcHJldmlldy1wbHVzLWlwYy1zaG93LWNvbnRleHQtbWVudScsXG4gICAgaGFuZGxlcklkLFxuICApXG59KVxuXG5pcGNSZW5kZXJlci5vbjwnc3luYy1zb3VyY2UnPignc3luYy1zb3VyY2UnLCAoXywgeyBpZCB9KSA9PiB7XG4gIGxldCBlbGVtZW50ID0gbGFzdENvbnRleHRNZW51VGFyZ2V0XG4gIGNvbnN0IHJzbSA9IGF0b21WYXJzLnJldlNvdXJjZU1hcFxuICBsZXQgbGluZXMgPSByc20uZ2V0KGVsZW1lbnQpXG5cbiAgd2hpbGUgKCFsaW5lcyAmJiBlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50XG4gICAgbGluZXMgPSByc20uZ2V0KGVsZW1lbnQpXG4gIH1cbiAgaWYgKCFsaW5lcykgcmV0dXJuXG5cbiAgaXBjUmVuZGVyZXIuc2VuZDwnYXRvbS1tYXJrZG93bi1wcmV2aWV3LXBsdXMtaXBjLXJlcXVlc3QtcmVwbHknPihcbiAgICAnYXRvbS1tYXJrZG93bi1wcmV2aWV3LXBsdXMtaXBjLXJlcXVlc3QtcmVwbHknLFxuICAgIGhhbmRsZXJJZCxcbiAgICB7XG4gICAgICBpZCxcbiAgICAgIHJlcXVlc3Q6ICdzeW5jLXNvdXJjZScsXG4gICAgICByZXN1bHQ6IE1hdGgubWluKC4uLmxpbmVzKSxcbiAgICB9LFxuICApXG59KVxuXG5pcGNSZW5kZXJlci5vbjwncmVsb2FkJz4oJ3JlbG9hZCcsIChfLCB7IGlkIH0pID0+IHtcbiAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gbnVsbFxuICBpcGNSZW5kZXJlci5zZW5kPCdhdG9tLW1hcmtkb3duLXByZXZpZXctcGx1cy1pcGMtcmVxdWVzdC1yZXBseSc+KFxuICAgICdhdG9tLW1hcmtkb3duLXByZXZpZXctcGx1cy1pcGMtcmVxdWVzdC1yZXBseScsXG4gICAgaGFuZGxlcklkLFxuICAgIHtcbiAgICAgIGlkLFxuICAgICAgcmVxdWVzdDogJ3JlbG9hZCcsXG4gICAgICByZXN1bHQ6IHVuZGVmaW5lZCxcbiAgICB9LFxuICApXG59KVxuXG53aW5kb3cub25iZWZvcmV1bmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmYWxzZVxufVxuXG5pcGNSZW5kZXJlci5vbjwnZ2V0LXRleC1jb25maWcnPignZ2V0LXRleC1jb25maWcnLCBhc3luYyAoXywgeyBpZCB9KSA9PiB7XG4gIGlwY1JlbmRlcmVyLnNlbmQ8J2F0b20tbWFya2Rvd24tcHJldmlldy1wbHVzLWlwYy1yZXF1ZXN0LXJlcGx5Jz4oXG4gICAgJ2F0b20tbWFya2Rvd24tcHJldmlldy1wbHVzLWlwYy1yZXF1ZXN0LXJlcGx5JyxcbiAgICBoYW5kbGVySWQsXG4gICAge1xuICAgICAgaWQsXG4gICAgICByZXF1ZXN0OiAnZ2V0LXRleC1jb25maWcnLFxuICAgICAgcmVzdWx0OiAoYXdhaXQgYXRvbVZhcnMubWF0aEpheCkuamF4VGVYQ29uZmlnKCksXG4gICAgfSxcbiAgKVxufSlcblxuaXBjUmVuZGVyZXIub248J2dldC1zZWxlY3Rpb24nPignZ2V0LXNlbGVjdGlvbicsIGFzeW5jIChfLCB7IGlkIH0pID0+IHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpXG4gIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24udG9TdHJpbmcoKVxuICBjb25zdCBzZWxlY3RlZE5vZGUgPSBzZWxlY3Rpb24gJiYgc2VsZWN0aW9uLmFuY2hvck5vZGVcblxuICBpcGNSZW5kZXJlci5zZW5kPCdhdG9tLW1hcmtkb3duLXByZXZpZXctcGx1cy1pcGMtcmVxdWVzdC1yZXBseSc+KFxuICAgICdhdG9tLW1hcmtkb3duLXByZXZpZXctcGx1cy1pcGMtcmVxdWVzdC1yZXBseScsXG4gICAgaGFuZGxlcklkLFxuICAgIHtcbiAgICAgIGlkLFxuICAgICAgcmVxdWVzdDogJ2dldC1zZWxlY3Rpb24nLFxuICAgICAgcmVzdWx0OiBzZWxlY3RlZFRleHQgJiYgc2VsZWN0ZWROb2RlID8gc2VsZWN0ZWRUZXh0IDogdW5kZWZpbmVkLFxuICAgIH0sXG4gIClcbn0pXG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gIGlmICghZXZlbnQudGFyZ2V0KSByZXR1cm5cbiAgY29uc3QgZWwgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnRcbiAgaWYgKGVsLnRhZ05hbWUgPT09ICdBJykge1xuICAgIGNvbnN0IGhyZWYgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKVxuICAgIGlmIChocmVmICYmIGhyZWYuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBjb25zdCBhbmNob3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkZWNvZGVVUklDb21wb25lbnQoaHJlZikuc2xpY2UoMSkpXG4gICAgICBpZiAoYW5jaG9yKSBhbmNob3Iuc2Nyb2xsSW50b1ZpZXcoKVxuICAgIH1cbiAgfVxufSlcbiJdfQ==","var DOCUMENT_FRAGMENT_NODE = 11;\n\nfunction morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // document-fragments dont have attributes so lets not do anything\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    // update attributes on original DOM element\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n        attr = toNodeAttrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                if (attr.prefix === 'xmlns'){\n                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix\n                }\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n        attr = fromNodeAttrs[d];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n\n            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n            }\n        } else {\n            if (!toNode.hasAttribute(attrName)) {\n                fromNode.removeAttribute(attrName);\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\nvar HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');\nvar HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();\n\nfunction createFragmentFromTemplate(str) {\n    var template = doc.createElement('template');\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n}\n\nfunction createFragmentFromRange(str) {\n    if (!range) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n}\n\nfunction createFragmentFromWrap(str) {\n    var fragment = doc.createElement('body');\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n}\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    str = str.trim();\n    if (HAS_TEMPLATE_SUPPORT) {\n      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which\n      // createContextualFragment doesn't support\n      // <template> support not available in IE\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    // If the target element is a virtual DOM node or SVG node then we may\n    // need to normalize the tag name before comparing. Normal HTML elements that are\n    // in the \"http://www.w3.org/1999/xhtml\"\n    // are converted to upper case\n    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower\n        return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower\n        return toNodeName === fromNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_FRAGMENT_NODE$1 = 11;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n  if (node) {\n      return (node.getAttribute && node.getAttribute('id')) || node.id;\n  }\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = Object.create(null);\n        var keyedRemovalList = [];\n\n        function addKeyedRemoval(key) {\n            keyedRemovalList.push(key);\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    // if we find a duplicate #id node in cache, replace `el` with cache value\n                    // and morph it to the child node.\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    } else {\n                      handleNodeAdded(curChild);\n                    }\n                } else {\n                  // recursively call for curChild and it's children to see if we find something in\n                  // fromNodesLookup\n                  handleNodeAdded(curChild);\n                }\n\n                curChild = nextSibling;\n            }\n        }\n\n        function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n            // We have processed all of the \"to nodes\". If curFromNodeChild is\n            // non-null then we still have some from nodes left over that need\n            // to be removed\n            while (curFromNodeChild) {\n                var fromNextSibling = curFromNodeChild.nextSibling;\n                if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                    // Since the node is keyed it might be matched up later so we defer\n                    // the actual removal to later\n                    addKeyedRemoval(curFromNodeKey);\n                } else {\n                    // NOTE: we skip nested keyed nodes from being removed since there is\n                    //       still a chance they will be matched up later\n                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                }\n                curFromNodeChild = fromNextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (!childrenOnly) {\n                // optional\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                // update attributes on original DOM element first\n                morphAttrs(fromEl, toEl);\n                // optional\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n              morphChildren(fromEl, toEl);\n            } else {\n              specialElHandlers.TEXTAREA(fromEl, toEl);\n            }\n        }\n\n        function morphChildren(fromEl, toEl) {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeKey;\n            var curFromNodeKey;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var matchingFromEl;\n\n            // walk the children\n            outer: while (curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeKey = getNodeKey(curToNodeChild);\n\n                // walk the fromNode children all the way through\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    // this means if the curFromNodeChild doesnt have a match with the curToNodeChild\n                    var isCompatible = undefined;\n\n                    if (curFromNodeType === curToNodeChild.nodeType) {\n                        if (curFromNodeType === ELEMENT_NODE) {\n                            // Both nodes being compared are Element nodes\n\n                            if (curToNodeKey) {\n                                // The target node has a key so we want to match it up with the correct element\n                                // in the original DOM tree\n                                if (curToNodeKey !== curFromNodeKey) {\n                                    // The current element in the original DOM tree does not have a matching key so\n                                    // let's check our lookup to see if there is a matching element in the original\n                                    // DOM tree\n                                    if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                        if (fromNextSibling === matchingFromEl) {\n                                            // Special case for single element removals. To avoid removing the original\n                                            // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                            // we will instead discard the current node and wait until the next\n                                            // iteration to properly match up the keyed target element with its matching\n                                            // element in the original tree\n                                            isCompatible = false;\n                                        } else {\n                                            // We found a matching keyed element somewhere in the original DOM tree.\n                                            // Let's move the original DOM node into the current position and morph\n                                            // it.\n\n                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                            // the `removeNode()` function for the node that is being discarded so that\n                                            // all lifecycle hooks are correctly invoked\n                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                            // fromNextSibling = curFromNodeChild.nextSibling;\n\n                                            if (curFromNodeKey) {\n                                                // Since the node is keyed it might be matched up later so we defer\n                                                // the actual removal to later\n                                                addKeyedRemoval(curFromNodeKey);\n                                            } else {\n                                                // NOTE: we skip nested keyed nodes from being removed since there is\n                                                //       still a chance they will be matched up later\n                                                removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                            }\n\n                                            curFromNodeChild = matchingFromEl;\n                                        }\n                                    } else {\n                                        // The nodes are not compatible since the \"to\" node has a key and there\n                                        // is no matching keyed node in the source tree\n                                        isCompatible = false;\n                                    }\n                                }\n                            } else if (curFromNodeKey) {\n                                // The original has a key\n                                isCompatible = false;\n                            }\n\n                            isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                            if (isCompatible) {\n                                // We found compatible DOM elements so transform\n                                // the current \"from\" node to match the current\n                                // target DOM node.\n                                // MORPH\n                                morphEl(curFromNodeChild, curToNodeChild);\n                            }\n\n                        } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                            // Both nodes being compared are Text or Comment nodes\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to\n                            // change the text value\n                            if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                            }\n\n                        }\n                    }\n\n                    if (isCompatible) {\n                        // Advance both the \"to\" child and the \"from\" child since we found a match\n                        // Nothing else to do as we already recursively called morphChildren above\n                        curToNodeChild = toNextSibling;\n                        curFromNodeChild = fromNextSibling;\n                        continue outer;\n                    }\n\n                    // No compatible match so remove the old node from the DOM and continue trying to find a\n                    // match in the original DOM. However, we only do this if the from node is not keyed\n                    // since it is possible that a keyed node might match up with a node somewhere else in the\n                    // target tree and we don't want to discard it just yet since it still might find a\n                    // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                    // that didn't find a home\n                    if (curFromNodeKey) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n\n                    curFromNodeChild = fromNextSibling;\n                } // END: while(curFromNodeChild) {}\n\n                // If we got this far then we did not find a candidate match for\n                // our \"to node\" and we exhausted all of the children \"from\"\n                // nodes. Therefore, we will just append the current \"to\" node\n                // to the end\n                if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                    fromEl.appendChild(matchingFromEl);\n                    // MORPH\n                    morphEl(matchingFromEl, curToNodeChild);\n                } else {\n                    var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                    if (onBeforeNodeAddedResult !== false) {\n                        if (onBeforeNodeAddedResult) {\n                            curToNodeChild = onBeforeNodeAddedResult;\n                        }\n\n                        if (curToNodeChild.actualize) {\n                            curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                        }\n                        fromEl.appendChild(curToNodeChild);\n                        handleNodeAdded(curToNodeChild);\n                    }\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphChildren(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n                return;\n            }\n\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n","import morph from 'morphdom';\nexport class UpdatePreview {\n    constructor(dom, mjController) {\n        this.dom = dom;\n        this.mjController = mjController;\n    }\n    async update(newDom, renderLaTeX) {\n        for (const m of Array.from(newDom.querySelectorAll('span.math'))) {\n            const mscr = m.firstElementChild;\n            if (!mscr || mscr.nodeName !== 'SCRIPT')\n                continue;\n            m.isSameNode = function (target) {\n                if (target.nodeName !== 'SPAN')\n                    return false;\n                const el = target;\n                if (!el.classList.contains('math'))\n                    return false;\n                const scr = el.querySelector('script');\n                if (!scr)\n                    return false;\n                return mscr.innerHTML === scr.innerHTML && mscr.type === scr.type;\n            };\n        }\n        try {\n            morph(this.dom, newDom, {\n                childrenOnly: true,\n                onBeforeElUpdated: function (fromEl, toEl) {\n                    return !fromEl.isEqualNode(toEl);\n                },\n                getNodeKey: function (node) {\n                    if (node.id && node.closest && node.closest('svg') !== null) {\n                        return '';\n                    }\n                    return node.id;\n                },\n            });\n        }\n        catch (e) {\n            console.error(e);\n            this.dom.innerHTML = newDom.innerHTML;\n        }\n        if (renderLaTeX) {\n            return this.mjController.queueTypeset(this.dom);\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBkYXRlLXByZXZpZXcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMtY2xpZW50L3VwZGF0ZS1wcmV2aWV3LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxNQUFNLFVBQVUsQ0FBQTtBQUc1QixNQUFNLE9BQU8sYUFBYTtJQUN4QixZQUNVLEdBQWdCLEVBQ2hCLFlBQStCO1FBRC9CLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFDaEIsaUJBQVksR0FBWixZQUFZLENBQW1CO0lBR3pDLENBQUM7SUFFTSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQWUsRUFBRSxXQUFvQjtRQUN2RCxLQUFLLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQUU7WUFDaEUsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLGlCQUE2QyxDQUFBO1lBQzVELElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxRQUFRO2dCQUFFLFNBQVE7WUFDakQsQ0FBQyxDQUFDLFVBQVUsR0FBRyxVQUFVLE1BQVk7Z0JBQ25DLElBQUksTUFBTSxDQUFDLFFBQVEsS0FBSyxNQUFNO29CQUFFLE9BQU8sS0FBSyxDQUFBO2dCQUM1QyxNQUFNLEVBQUUsR0FBRyxNQUF5QixDQUFBO2dCQUNwQyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO29CQUFFLE9BQU8sS0FBSyxDQUFBO2dCQUNoRCxNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFBO2dCQUN0QyxJQUFJLENBQUMsR0FBRztvQkFBRSxPQUFPLEtBQUssQ0FBQTtnQkFDdEIsT0FBTyxJQUFJLENBQUMsU0FBUyxLQUFLLEdBQUcsQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFBO1lBQ25FLENBQUMsQ0FBQTtTQUNGO1FBRUQsSUFBSTtZQUNGLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLE1BQU0sRUFBRTtnQkFDdEIsWUFBWSxFQUFFLElBQUk7Z0JBQ2xCLGlCQUFpQixFQUFFLFVBQVUsTUFBTSxFQUFFLElBQUk7b0JBR3ZDLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFBO2dCQUNsQyxDQUFDO2dCQUNELFVBQVUsRUFBRSxVQUFVLElBQWE7b0JBQ2pDLElBQUksSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxFQUFFO3dCQUMzRCxPQUFPLEVBQUUsQ0FBQTtxQkFDVjtvQkFDRCxPQUFPLElBQUksQ0FBQyxFQUFFLENBQUE7Z0JBQ2hCLENBQUM7YUFDRixDQUFDLENBQUE7U0FDSDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQTtZQUNoQixJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFBO1NBQ3RDO1FBRUQsSUFBSSxXQUFXLEVBQUU7WUFDZixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQTtTQUNoRDtJQUNILENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb3JwaCBmcm9tICdtb3JwaGRvbSdcbmltcG9ydCB7IE1hdGhKYXhDb250cm9sbGVyIH0gZnJvbSAnLi9tYXRoamF4LWhlbHBlcidcblxuZXhwb3J0IGNsYXNzIFVwZGF0ZVByZXZpZXcge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGRvbTogSFRNTEVsZW1lbnQsXG4gICAgcHJpdmF0ZSBtakNvbnRyb2xsZXI6IE1hdGhKYXhDb250cm9sbGVyLFxuICApIHtcbiAgICAvKiBuby1vcCAqL1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHVwZGF0ZShuZXdEb206IEVsZW1lbnQsIHJlbmRlckxhVGVYOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgZm9yIChjb25zdCBtIG9mIEFycmF5LmZyb20obmV3RG9tLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NwYW4ubWF0aCcpKSkge1xuICAgICAgY29uc3QgbXNjciA9IG0uZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTFNjcmlwdEVsZW1lbnQgfCBudWxsXG4gICAgICBpZiAoIW1zY3IgfHwgbXNjci5ub2RlTmFtZSAhPT0gJ1NDUklQVCcpIGNvbnRpbnVlXG4gICAgICBtLmlzU2FtZU5vZGUgPSBmdW5jdGlvbiAodGFyZ2V0OiBOb2RlKSB7XG4gICAgICAgIGlmICh0YXJnZXQubm9kZU5hbWUgIT09ICdTUEFOJykgcmV0dXJuIGZhbHNlXG4gICAgICAgIGNvbnN0IGVsID0gdGFyZ2V0IGFzIEhUTUxTcGFuRWxlbWVudFxuICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5jb250YWlucygnbWF0aCcpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgY29uc3Qgc2NyID0gZWwucXVlcnlTZWxlY3Rvcignc2NyaXB0JylcbiAgICAgICAgaWYgKCFzY3IpIHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gbXNjci5pbm5lckhUTUwgPT09IHNjci5pbm5lckhUTUwgJiYgbXNjci50eXBlID09PSBzY3IudHlwZVxuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBtb3JwaCh0aGlzLmRvbSwgbmV3RG9tLCB7XG4gICAgICAgIGNoaWxkcmVuT25seTogdHJ1ZSxcbiAgICAgICAgb25CZWZvcmVFbFVwZGF0ZWQ6IGZ1bmN0aW9uIChmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgICAvLyBkbyBub3QgcmVjdXJzZSBpbnRvIGVsZW1lbnQgY2hpbGRyZW4gaWYgaXNFcXVhbE5vZGUgPT09IHRydWVcbiAgICAgICAgICAvLyBzcGVjIC0gaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW5vZGUtZXF1YWxzXG4gICAgICAgICAgcmV0dXJuICFmcm9tRWwuaXNFcXVhbE5vZGUodG9FbClcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Tm9kZUtleTogZnVuY3Rpb24gKG5vZGU6IEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAobm9kZS5pZCAmJiBub2RlLmNsb3Nlc3QgJiYgbm9kZS5jbG9zZXN0KCdzdmcnKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnIC8vIGlnbm9yZSBTVkcgaWRcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGUuaWRcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgdGhpcy5kb20uaW5uZXJIVE1MID0gbmV3RG9tLmlubmVySFRNTFxuICAgIH1cblxuICAgIGlmIChyZW5kZXJMYVRlWCkge1xuICAgICAgcmV0dXJuIHRoaXMubWpDb250cm9sbGVyLnF1ZXVlVHlwZXNldCh0aGlzLmRvbSlcbiAgICB9XG4gIH1cbn1cbiJdfQ==","export function processHTMLString(element) {\n    const msvgh = document.getElementById('MathJax_SVG_Hidden');\n    const svgGlyphs = msvgh && msvgh.parentElement;\n    if (svgGlyphs !== null) {\n        return svgGlyphs.outerHTML + element.innerHTML;\n    }\n    else {\n        return element.innerHTML;\n    }\n}\nexport class MathJaxController {\n    constructor(userMacros, mathJaxConfig) {\n        this.userMacros = userMacros;\n        this.mathJaxConfig = mathJaxConfig;\n        this.readyPromise = this.attachMathJax();\n    }\n    static async create(userMacros, mathJaxConfig) {\n        const controller = new MathJaxController(userMacros, mathJaxConfig);\n        await controller.readyPromise;\n        return controller;\n    }\n    dispose() {\n        const script = document.head.querySelector(`script[src='${MathJaxController.mjSrc}']`);\n        if (script)\n            script.remove();\n    }\n    jaxTeXConfig() {\n        return {\n            extensions: this.mathJaxConfig.texExtensions,\n            Macros: this.userMacros,\n            equationNumbers: this.mathJaxConfig.numberEquations\n                ? {\n                    autoNumber: 'AMS',\n                    useLabelIds: false,\n                }\n                : {},\n        };\n    }\n    async queueTypeset(domElement) {\n        const hasUnprocessedMath = Array.from(document.querySelectorAll('script[type^=\"math/tex\"]')).some((x) => !x.id);\n        if (!hasUnprocessedMath)\n            return;\n        return new Promise((resolve) => {\n            if (MathJax.InputJax.TeX) {\n                MathJax.Hub.Queue(['resetEquationNumbers', MathJax.InputJax.TeX]);\n                if (this.mathJaxConfig.numberEquations) {\n                    MathJax.Hub.Queue(['PreProcess', MathJax.Hub]);\n                    MathJax.Hub.Queue(['Reprocess', MathJax.Hub]);\n                }\n            }\n            MathJax.Hub.Queue(['Typeset', MathJax.Hub, domElement]);\n            MathJax.Hub.Queue([resolve]);\n        });\n    }\n    async attachMathJax() {\n        await injectScript(MathJaxController.mjSrc);\n        MathJax.Hub.Config({\n            jax: ['input/TeX', `output/${this.mathJaxConfig.latexRenderer}`],\n            extensions: [],\n            TeX: this.jaxTeXConfig(),\n            'HTML-CSS': {\n                availableFonts: [],\n                webFont: 'TeX',\n                imageFont: null,\n                undefinedFamily: this.mathJaxConfig.undefinedFamily,\n                mtextFontInherit: true,\n            },\n            messageStyle: 'none',\n            showMathMenu: false,\n            skipStartupTypeset: true,\n        });\n        MathJax.Hub.Configured();\n    }\n}\nMathJaxController.mjSrc = `${global.require.resolve('mathjax')}?delayStartupUntil=configured`;\nasync function injectScript(scriptSrc) {\n    const script = document.createElement('script');\n    script.src = scriptSrc;\n    script.type = 'text/javascript';\n    document.head.appendChild(script);\n    return new Promise((resolve) => {\n        script.addEventListener('load', () => resolve());\n    });\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0aGpheC1oZWxwZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMtY2xpZW50L21hdGhqYXgtaGVscGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQU9BLE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxPQUFnQjtJQUNoRCxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLG9CQUFvQixDQUFDLENBQUE7SUFDM0QsTUFBTSxTQUFTLEdBQUcsS0FBSyxJQUFJLEtBQUssQ0FBQyxhQUFhLENBQUE7SUFDOUMsSUFBSSxTQUFTLEtBQUssSUFBSSxFQUFFO1FBQ3RCLE9BQU8sU0FBUyxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFBO0tBQy9DO1NBQU07UUFDTCxPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUE7S0FDekI7QUFDSCxDQUFDO0FBRUQsTUFBTSxPQUFPLGlCQUFpQjtJQU01QixZQUNVLFVBQWtCLEVBQ2xCLGFBQTRCO1FBRDVCLGVBQVUsR0FBVixVQUFVLENBQVE7UUFDbEIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFFcEMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUE7SUFDMUMsQ0FBQztJQUVNLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQWtCLEVBQUUsYUFBNEI7UUFDekUsTUFBTSxVQUFVLEdBQUcsSUFBSSxpQkFBaUIsQ0FBQyxVQUFVLEVBQUUsYUFBYSxDQUFDLENBQUE7UUFDbkUsTUFBTSxVQUFVLENBQUMsWUFBWSxDQUFBO1FBQzdCLE9BQU8sVUFBVSxDQUFBO0lBQ25CLENBQUM7SUFHTSxPQUFPO1FBQ1osTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLElBQUssQ0FBQyxhQUFhLENBQ3pDLGVBQWUsaUJBQWlCLENBQUMsS0FBSyxJQUFJLENBQzNDLENBQUE7UUFDRCxJQUFJLE1BQU07WUFBRSxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUE7SUFD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QTtJQUMvQixRQUFRLENBQUMsSUFBSyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUNsQyxPQUFPLElBQUksT0FBTyxDQUFPLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDbkMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFBO0lBQ2xELENBQUMsQ0FBQyxDQUFBO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vXG4vLyBtYXRoamF4LWhlbHBlclxuLy9cbi8vIFRoaXMgbW9kdWxlIHdpbGwgaGFuZGxlIGxvYWRpbmcgdGhlIE1hdGhKYXggZW52aXJvbm1lbnQgYW5kIHByb3ZpZGUgYSB3cmFwcGVyXG4vLyBmb3IgY2FsbHMgdG8gTWF0aEpheCB0byBwcm9jZXNzIExhVGVYIGVxdWF0aW9ucy5cbi8vXG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzSFRNTFN0cmluZyhlbGVtZW50OiBFbGVtZW50KSB7XG4gIGNvbnN0IG1zdmdoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ01hdGhKYXhfU1ZHX0hpZGRlbicpXG4gIGNvbnN0IHN2Z0dseXBocyA9IG1zdmdoICYmIG1zdmdoLnBhcmVudEVsZW1lbnRcbiAgaWYgKHN2Z0dseXBocyAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzdmdHbHlwaHMub3V0ZXJIVE1MICsgZWxlbWVudC5pbm5lckhUTUxcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlbWVudC5pbm5lckhUTUxcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWF0aEpheENvbnRyb2xsZXIge1xuICBwcml2YXRlIHN0YXRpYyBtalNyYyA9IGAke2dsb2JhbC5yZXF1aXJlLnJlc29sdmUoXG4gICAgJ21hdGhqYXgnLFxuICApfT9kZWxheVN0YXJ0dXBVbnRpbD1jb25maWd1cmVkYFxuICBwcml2YXRlIHJlYWRvbmx5IHJlYWR5UHJvbWlzZTogUHJvbWlzZTx2b2lkPlxuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB1c2VyTWFjcm9zOiBvYmplY3QsXG4gICAgcHJpdmF0ZSBtYXRoSmF4Q29uZmlnOiBNYXRoSmF4Q29uZmlnLFxuICApIHtcbiAgICB0aGlzLnJlYWR5UHJvbWlzZSA9IHRoaXMuYXR0YWNoTWF0aEpheCgpXG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGNyZWF0ZSh1c2VyTWFjcm9zOiBvYmplY3QsIG1hdGhKYXhDb25maWc6IE1hdGhKYXhDb25maWcpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IE1hdGhKYXhDb250cm9sbGVyKHVzZXJNYWNyb3MsIG1hdGhKYXhDb25maWcpXG4gICAgYXdhaXQgY29udHJvbGxlci5yZWFkeVByb21pc2VcbiAgICByZXR1cm4gY29udHJvbGxlclxuICB9XG5cbiAgLy8gZm9yIHRlc3RpbmdcbiAgcHVibGljIGRpc3Bvc2UoKTogdm9pZCB7XG4gICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuaGVhZCEucXVlcnlTZWxlY3RvcihcbiAgICAgIGBzY3JpcHRbc3JjPScke01hdGhKYXhDb250cm9sbGVyLm1qU3JjfSddYCxcbiAgICApXG4gICAgaWYgKHNjcmlwdCkgc2NyaXB0LnJlbW92ZSgpXG4gIH1cblxuICBwdWJsaWMgamF4VGVYQ29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBleHRlbnNpb25zOiB0aGlzLm1hdGhKYXhDb25maWcudGV4RXh0ZW5zaW9ucyxcbiAgICAgIE1hY3JvczogdGhpcy51c2VyTWFjcm9zLFxuICAgICAgZXF1YXRpb25OdW1iZXJzOiB0aGlzLm1hdGhKYXhDb25maWcubnVtYmVyRXF1YXRpb25zXG4gICAgICAgID8ge1xuICAgICAgICAgICAgYXV0b051bWJlcjogJ0FNUycsXG4gICAgICAgICAgICB1c2VMYWJlbElkczogZmFsc2UsXG4gICAgICAgICAgfVxuICAgICAgICA6IHt9LFxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBxdWV1ZVR5cGVzZXQoZG9tRWxlbWVudDogTm9kZSkge1xuICAgIGNvbnN0IGhhc1VucHJvY2Vzc2VkTWF0aCA9IEFycmF5LmZyb20oXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbdHlwZV49XCJtYXRoL3RleFwiXScpLFxuICAgICkuc29tZSgoeCkgPT4gIXguaWQpXG4gICAgaWYgKCFoYXNVbnByb2Nlc3NlZE1hdGgpIHJldHVyblxuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgaWYgKE1hdGhKYXguSW5wdXRKYXguVGVYKSB7XG4gICAgICAgIE1hdGhKYXguSHViLlF1ZXVlKFsncmVzZXRFcXVhdGlvbk51bWJlcnMnLCBNYXRoSmF4LklucHV0SmF4LlRlWF0pXG4gICAgICAgIGlmICh0aGlzLm1hdGhKYXhDb25maWcubnVtYmVyRXF1YXRpb25zKSB7XG4gICAgICAgICAgTWF0aEpheC5IdWIuUXVldWUoWydQcmVQcm9jZXNzJywgTWF0aEpheC5IdWJdKVxuICAgICAgICAgIE1hdGhKYXguSHViLlF1ZXVlKFsnUmVwcm9jZXNzJywgTWF0aEpheC5IdWJdKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE1hdGhKYXguSHViLlF1ZXVlKFsnVHlwZXNldCcsIE1hdGhKYXguSHViLCBkb21FbGVtZW50XSlcbiAgICAgIE1hdGhKYXguSHViLlF1ZXVlKFtyZXNvbHZlXSlcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBhdHRhY2hNYXRoSmF4KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEF0dGFjaCBNYXRoSmF4IHNjcmlwdFxuICAgIGF3YWl0IGluamVjdFNjcmlwdChNYXRoSmF4Q29udHJvbGxlci5talNyYylcblxuICAgIE1hdGhKYXguSHViLkNvbmZpZyh7XG4gICAgICBqYXg6IFsnaW5wdXQvVGVYJywgYG91dHB1dC8ke3RoaXMubWF0aEpheENvbmZpZy5sYXRleFJlbmRlcmVyfWBdLFxuICAgICAgZXh0ZW5zaW9uczogW10sXG4gICAgICBUZVg6IHRoaXMuamF4VGVYQ29uZmlnKCksXG4gICAgICAnSFRNTC1DU1MnOiB7XG4gICAgICAgIGF2YWlsYWJsZUZvbnRzOiBbXSxcbiAgICAgICAgd2ViRm9udDogJ1RlWCcsXG4gICAgICAgIGltYWdlRm9udDogbnVsbCBhcyBhbnksIC8vIFRPRE86IGNvbXBsYWluIG9uIERUXG4gICAgICAgIHVuZGVmaW5lZEZhbWlseTogdGhpcy5tYXRoSmF4Q29uZmlnLnVuZGVmaW5lZEZhbWlseSBhcyBhbnksIC8vIFRPRE86IGNvbXBsYWluIG9uIERUXG4gICAgICAgIG10ZXh0Rm9udEluaGVyaXQ6IHRydWUsXG4gICAgICB9LFxuICAgICAgbWVzc2FnZVN0eWxlOiAnbm9uZScsXG4gICAgICBzaG93TWF0aE1lbnU6IGZhbHNlLFxuICAgICAgc2tpcFN0YXJ0dXBUeXBlc2V0OiB0cnVlLFxuICAgIH0pXG4gICAgTWF0aEpheC5IdWIuQ29uZmlndXJlZCgpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5qZWN0U2NyaXB0KHNjcmlwdFNyYzogc3RyaW5nKSB7XG4gIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gIHNjcmlwdC5zcmMgPSBzY3JpcHRTcmNcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICBkb2N1bWVudC5oZWFkIS5hcHBlbmRDaGlsZChzY3JpcHQpXG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIHNjcmlwdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4gcmVzb2x2ZSgpKVxuICB9KVxufVxuIl19","export function handlePromise(promise) {\n    if (!promise)\n        return;\n    promise.catch((error) => {\n        console.error(error);\n    });\n}\nimport { lstatSync, existsSync } from 'fs';\nexport function isFileSync(filePath) {\n    if (!existsSync(filePath))\n        return false;\n    return lstatSync(filePath).isFile();\n}\nexport function resolveElement(root, pathToToken) {\n    let element = root;\n    for (const token of pathToToken) {\n        const candidateElement = element\n            .querySelectorAll(`:scope > ${token.tag}`)\n            .item(token.index);\n        if (candidateElement) {\n            element = candidateElement;\n        }\n        else {\n            break;\n        }\n    }\n    if (element === root)\n        return undefined;\n    return element;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy1jbGllbnQvdXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLFVBQVUsYUFBYSxDQUFDLE9BQXFCO0lBQ2pELElBQUksQ0FBQyxPQUFPO1FBQUUsT0FBTTtJQUNwQixPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBWSxFQUFFLEVBQUU7UUFDN0IsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUN0QixDQUFDLENBQUMsQ0FBQTtBQUNKLENBQUM7QUFDRCxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLElBQUksQ0FBQTtBQUMxQyxNQUFNLFVBQVUsVUFBVSxDQUFDLFFBQWdCO0lBQ3pDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDO1FBQUUsT0FBTyxLQUFLLENBQUE7SUFDdkMsT0FBTyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUE7QUFDckMsQ0FBQztBQUVELE1BQU0sVUFBVSxjQUFjLENBQzVCLElBQWEsRUFDYixXQUFrRDtJQUVsRCxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUE7SUFDbEIsS0FBSyxNQUFNLEtBQUssSUFBSSxXQUFXLEVBQUU7UUFDL0IsTUFBTSxnQkFBZ0IsR0FBdUIsT0FBTzthQUNqRCxnQkFBZ0IsQ0FBQyxZQUFZLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQzthQUN6QyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBZ0IsQ0FBQTtRQUNuQyxJQUFJLGdCQUFnQixFQUFFO1lBQ3BCLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQTtTQUMzQjthQUFNO1lBQ0wsTUFBSztTQUNOO0tBQ0Y7SUFFRCxJQUFJLE9BQU8sS0FBSyxJQUFJO1FBQUUsT0FBTyxTQUFTLENBQUE7SUFDdEMsT0FBTyxPQUFPLENBQUE7QUFDaEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBoYW5kbGVQcm9taXNlKHByb21pc2U6IFByb21pc2U8YW55Pik6IHZvaWQge1xuICBpZiAoIXByb21pc2UpIHJldHVyblxuICBwcm9taXNlLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKVxuICB9KVxufVxuaW1wb3J0IHsgbHN0YXRTeW5jLCBleGlzdHNTeW5jIH0gZnJvbSAnZnMnXG5leHBvcnQgZnVuY3Rpb24gaXNGaWxlU3luYyhmaWxlUGF0aDogc3RyaW5nKSB7XG4gIGlmICghZXhpc3RzU3luYyhmaWxlUGF0aCkpIHJldHVybiBmYWxzZVxuICByZXR1cm4gbHN0YXRTeW5jKGZpbGVQYXRoKS5pc0ZpbGUoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnQoXG4gIHJvb3Q6IEVsZW1lbnQsXG4gIHBhdGhUb1Rva2VuOiBBcnJheTx7IHRhZzogc3RyaW5nOyBpbmRleDogbnVtYmVyIH0+LFxuKTogRWxlbWVudCB8IHVuZGVmaW5lZCB7XG4gIGxldCBlbGVtZW50ID0gcm9vdFxuICBmb3IgKGNvbnN0IHRva2VuIG9mIHBhdGhUb1Rva2VuKSB7XG4gICAgY29uc3QgY2FuZGlkYXRlRWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gZWxlbWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3JBbGwoYDpzY29wZSA+ICR7dG9rZW4udGFnfWApXG4gICAgICAuaXRlbSh0b2tlbi5pbmRleCkgYXMgSFRNTEVsZW1lbnRcbiAgICBpZiAoY2FuZGlkYXRlRWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IGNhbmRpZGF0ZUVsZW1lbnRcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoZWxlbWVudCA9PT0gcm9vdCkgcmV0dXJuIHVuZGVmaW5lZCAvLyBEbyBub3QganVtcCB0byB0aGUgdG9wIG9mIHRoZSBwcmV2aWV3IGZvciBiYWQgc3luY3NcbiAgcmV0dXJuIGVsZW1lbnRcbn1cbiJdfQ==","export function getMedia(document) {\n    return document.querySelectorAll('img[src],audio[src],video[src],link[href]');\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC1jb21tb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbC1jb21tb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsTUFBTSxVQUFVLFFBQVEsQ0FBQyxRQUFzQjtJQUM3QyxPQUFPLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FDOUIsMkNBQTJDLENBRzVDLENBQUE7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGdldE1lZGlhKGRvY3VtZW50OiBIVE1MRG9jdW1lbnQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgJ2ltZ1tzcmNdLGF1ZGlvW3NyY10sdmlkZW9bc3JjXSxsaW5rW2hyZWZdJyxcbiAgKSBhcyBOb2RlTGlzdE9mPFxuICAgIEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MQXVkaW9FbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudCB8IEhUTUxMaW5rRWxlbWVudFxuICA+XG59XG4iXX0="],"names":["$parcel$global","globalThis","self","window","global","$cecc57bd705d34a3f46722639be3a1$var$_electron","_electron","a","Object","defineProperty","value","range","doc","document","undefined","HAS_TEMPLATE_SUPPORT","createElement","HAS_RANGE_SUPPORT","createRange","toElement","str","trim","template","innerHTML","content","childNodes","createFragmentFromTemplate","selectNode","body","createContextualFragment","createFragmentFromRange","fragment","createFragmentFromWrap","compareNodeNames","fromEl","toEl","fromCodeStart","toCodeStart","fromNodeName","nodeName","toNodeName","charCodeAt","toUpperCase","syncBooleanAttrProp","name","setAttribute","removeAttribute","specialElHandlers","OPTION","parentNode","parentName","hasAttribute","selected","selectedIndex","INPUT","TEXTAREA","newValue","firstChild","oldValue","nodeValue","placeholder","SELECT","optgroup","i","curChild","nextSibling","noop","defaultGetNodeKey","node","getAttribute","id","morphAttrs","morphdom","fromNode","toNode","attr","attrName","attrNamespaceURI","attrValue","toNodeAttrs","attributes","nodeType","length","namespaceURI","localName","getAttributeNS","prefix","setAttributeNS","fromNodeAttrs","d","hasAttributeNS","removeAttributeNS","options","toNodeHtml","getNodeKey","onBeforeNodeAdded","onNodeAdded","onBeforeElUpdated","onElUpdated","onBeforeNodeDiscarded","onNodeDiscarded","onBeforeElChildrenUpdated","childrenOnly","fromNodesLookup","create","keyedRemovalList","addKeyedRemoval","key","push","removeNode","skipKeyedNodes","removeChild","walkDiscardedChildNodes","handleNodeAdded","el","unmatchedFromEl","replaceChild","morphEl","toElKey","curToNodeKey","curFromNodeKey","fromNextSibling","toNextSibling","matchingFromEl","curToNodeChild","curFromNodeChild","outer","isSameNode","curFromNodeType","isCompatible","insertBefore","appendChild","onBeforeNodeAddedResult","actualize","ownerDocument","cleanupFromEl","specialElHandler","morphChildren","indexTree","morphedNode","morphedNodeType","toNodeType","nextChild","moveChildren","createElementNS","len","elToRemove","$c9e2da52b16bd8155d72173b7e42f$var$_morphdom","$e730ac64d1f01aff290702b7ff3c8beb$exports","constructor","dom","mjController","this","[object Object]","newDom","renderLaTeX","m","Array","from","querySelectorAll","mscr","firstElementChild","target","classList","contains","scr","querySelector","type","default","isEqualNode","closest","e","console","error","queueTypeset","element","msvgh","getElementById","svgGlyphs","parentElement","outerHTML","MathJaxController","userMacros","mathJaxConfig","readyPromise","attachMathJax","controller","dispose","script","head","mjSrc","remove","jaxTeXConfig","extensions","texExtensions","Macros","equationNumbers","numberEquations","autoNumber","useLabelIds","domElement","some","x","Promise","resolve","MathJax","InputJax","TeX","Hub","Queue","async","scriptSrc","src","addEventListener","injectScript","Config","jax","latexRenderer","HTML-CSS","availableFonts","webFont","imageFont","undefinedFamily","mtextFontInherit","messageStyle","showMathMenu","skipStartupTypeset","Configured","require","promise","catch","filePath","$a137d74b5d1f961e65402b2544f0d7a$var$_fs","existsSync","lstatSync","isFile","root","pathToToken","token","candidateElement","tag","item","index","_fs","$cecc57bd705d34a3f46722639be3a1$var$util","$cecc57bd705d34a3f46722639be3a1$var$_interopRequireWildcard","$a137d74b5d1f961e65402b2544f0d7a$exports","handlerId","nativePageScrollKeys","err","ipcRenderer","send","message","stack","evt","reason","atomVars","mathJax","resFn","p","mkResPromise","sourceLineMap","Map","revSourceMap","WeakMap","updatePreview","on","_evt","params","documentElement","dataset","markdownPreviewPlusContext","context","style","setProperty","pdfExportOptions","width","val","map","Error","slsm","rsm","lineS","path","entries","line","parseInt","elem","util","resolveElement","set","rsmel","get","firstLine","lastLine","slm","lines","keys","sort","b","lowix","findIndex","highix","low","high","norm","meanScroll","slice","weight","getBoundingClientRect","top","scrollTop","clientHeight","scroll","_event","styles","styleElem","join","oldsrc","v","imgs","$e5233bf2e340b87217b858bda672f7a$exports","getMedia","img","ovs","ov","tagName","match","flash","scrollIntoViewIfNeeded","add","setTimeout","html","preview","UpdatePreview","domDocument","DOMParser","parseFromString","hasChildNodes","container","headElement","update","request","result","$fae90f0a73bce816af5ed733fe$exports","processHTMLString","readyState","loaded","removeEventListener","baseElement","keyEventHandler","altKey","ctrlKey","shiftKey","metaKey","code","data","bubbles","cancelable","composed","detail","isComposing","location","repeat","preventDefault","lastContextMenuTarget","href","msg","errorDiv","event","deltaY","stopPropagation","height","visible","filter","_line","bottom","_elem","max","Math","min","bind","_","onbeforeunload","selection","getSelection","selectedText","toString","selectedNode","anchorNode","startsWith","anchor","decodeURIComponent","scrollIntoView"],"version":3,"file":"main.js.map"}